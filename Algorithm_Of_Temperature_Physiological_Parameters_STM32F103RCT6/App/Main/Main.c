/*********************************************************************************************************
* 模块名称：Main.c
* 摘    要：主文件，包含软硬件初始化函数和main函数
* 当前版本：1.0.0
* 作    者：SZLY(COPYRIGHT 2018 - 2020 SZLY. All rights reserved.)
* 完成日期：2020年01月01日
* 内    容：
* 注    意：注意勾选Options for Target 'Target1'->Code Generation->Use MicroLIB，否则printf无法使用                                                                  
**********************************************************************************************************
* 取代版本：
* 作    者：
* 完成日期：
* 修改内容：
* 修改文件：
*********************************************************************************************************/

/*********************************************************************************************************
*                                              包含头文件
*********************************************************************************************************/
#include "Main.h"
#include "stm32f10x_conf.h"
#include "NVIC.h"
#include "SysTick.h"
#include "RCC.h"
#include "Timer.h"
#include "UART1.h"
#include "LED.h"
#include "Wave.h"
#include "ProcHostCmd.h"
#include "PackUnpack.h"
//#include "DAC.h"
#include "SendDataToHost.h"
#include "ADC.h"
#include "KeyOne.h"
#include "ProcKeyOne.h"
#include "Temp.h"
#include "TempRext.h"

/*********************************************************************************************************
*                                              宏定义
*********************************************************************************************************/

/*********************************************************************************************************
*                                              内部变量
*********************************************************************************************************/
static u8 reckonBegin;      // 表示的是是否成功采集到S1/S2通道的电压数据，目的是是否计算后续对应探头的阻值与温度值

static i8 keyBegin;         
// 表示的是在1s内通道自动切换的轮数（一轮表示从PA通道开始按照keyNumber规定的通道自动切换回到PA通道，在1s内需要采集x个体温值说明在1s内通道自动切换的轮数为x轮）
// 规定1s内采集的体温值个数为5次，因此1s内通道自动切换的轮数为5轮，keyBegin为0时表示未采集到体温数据

static u8 RestoreJudge;     
// 表示的是当体温探头导联脱落时值为TRUE，为体温探头导联重新连接时从头开始采集数据做准备，此刻keyNumber与keyBegin的值都为0，表示通道停止自动切换且未采集到体温数据
// 当体温探头导联重新连接时值为FALSE，表示已完成通道切换状态与体温采集轮数的初始化，此刻keyNumber的值为1表示通道在PA通道，keyBegin的值为0表示未采集到体温数据

static u8 ReadTOffValue;    // 表示的是T_off位置采集的电平情况，1为高电平，0为低电平
static double PA_Val;       // 表示的是PA通道采集的电压值
static double PB_Val;       // 表示的是PB通道采集的电压值

// 表示的是通过PA与PB各自通道采集到的电压值计算得到的C1和C2系数
static double C1;
static double C2;

static double RextVariate;  // 表示的是通过PA、PB与S1或S2通道采集到的电压值计算得到的热敏探头的阻值
static u8 arrNum;           // 表示的是储存温度值的数组的元素个数
/*********************************************************************************************************
*                                              全局变量
*********************************************************************************************************/
u8      keyNumber;               // 表示的是通道自动切换的顺序（PA->PB->S1/S2通道->PA，当值为0时停止切换通道）
u8      keyChange;               // 表示的是是否通过按下按钮选择通道
u8      s_i20msBegin;            // 表示的是60ms任务当中通道自动切换功能已执行完毕，开启20ms数据采集的计时
double  arrTempVariate[10];      // 表示的是储存温度值的数组
u8      s_arrTempData[6] = {0};  // 表示的是PCT协议中体温数据包的数组并进行初始化
/*********************************************************************************************************
*                                              枚举结构体定义
*********************************************************************************************************/

/*********************************************************************************************************
*                                              内部函数声明
*********************************************************************************************************/
static  void  InitSoftware(void);              // 初始化软件相关的模块
static  void  InitHardware(void);              // 初始化硬件相关的模块
static  void  Proc2msTask(void);               // 2ms处理任务
static  void  Proc60msTask(void);              // 60ms处理任务
static  void  Proc60msAfter20msTask(void);     // 60ms后紧跟着的20ms处理任务
static  void  Proc1SecTask(void);              // 1s处理任务
/*********************************************************************************************************
*                                              内部函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称：InitSoftware
* 函数功能：所有的软件相关的模块初始化函数都放在此函数中
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
static  void  InitSoftware(void)
{
  InitPackUnpack();         //初始化PackUnpack模块
  InitProcHostCmd();        //初始化ProcHostCmd模块
  InitSendDataToHost();     //初始化SendDataToHost模块
  InitVariable();           //初始化参数值
}

/*********************************************************************************************************
* 函数名称：InitHardware
* 函数功能：所有的硬件相关的模块初始化函数都放在此函数中
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
static  void  InitHardware(void)
{  
  SystemInit();       //系统初始化
  InitRCC();          //初始化RCC模块
  InitNVIC();         //初始化NVIC模块
  InitUART1(115200);  //初始化UART模块
  InitTimer();        //初始化Timer模块
  InitLED();          //初始化LED模块
  InitSysTick();      //初始化SysTick模块
  InitKeyOne();       //初始化KeyOne模块
  InitProcKeyOne();   //初始化ProcKeyOne模块
//  InitDAC();          //初始化DAC模块
  InitADC();          //初始化ADC模块
  InitTemp();         //初始化Temp模块
}


/*********************************************************************************************************
* 函数名称：Proc2msTask
* 函数功能：2ms处理任务 
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
static  void  Proc2msTask(void)    // 按键扫描与识别（每10ms进行一次按键识别）
{ 
  static u8 s_iCnt = 0;

  if(Get2msFlag())  //判断10ms标志状态
  {      
    if(s_iCnt >= 5)
    { 
      ScanKeyOne(KEY_NAME_KEY1, ProcKeyUpKey1, ProcKeyDownKey1);
      ScanKeyOne(KEY_NAME_KEY2, ProcKeyUpKey2, ProcKeyDownKey2);
      ScanKeyOne(KEY_NAME_KEY3, ProcKeyUpKey3, ProcKeyDownKey3);

      s_iCnt = 0;
    }
    else
    {
      s_iCnt++;
    } 
    
    Clr2msFlag();   //清除2ms标志
  }
  
}

/*********************************************************************************************************
* 函数名称：Proc60msTask
* 函数功能：60ms处理任务
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
static  void  Proc60msTask(void)   // 通道切换功能，为后续采集各个电压数据和计算体温数据做准备
{ 
  if(Get60msFlag())                // 判断60ms标志状态
  {
    if(keyNumber == 1)             // 通道切换从PA通道开始
    {
      TempWriteBit(T_PA);          // PA通道相关引脚赋予高电平（工作）状态
    }
    else if(keyNumber == 2)        // 通道切换为PB通道
    {
      TempWriteBit(T_PB);          // PB通道相关引脚赋予高电平（工作）状态
    }
    else if(keyNumber == 3)        // 通道切换为S1/S2测量通道
    {
      if(BoolKeyRenew() == FALSE)  // 检查按键选择的通道是否为S1/S2测量通道
      {
        if(BoolKeyNum() == 1)      // 判断通道是S1还是S2通道
        {
          TempWriteBit(T_SENS1);   // S1通道相关引脚赋予高电平（工作）状态
        }
        else
        {
          TempWriteBit(T_SENS2);   // S2通道相关引脚赋予高电平（工作）状态
        }
      }
    }
    else                           // 通道停止自动切换
    {
      
    }
    
    if(keyNumber != 0)             // 当通道切换从每个通道结束之后
    {
      s_i20msBegin = TRUE;         // 开启20ms数据采集的计时
    }

    Clr60msFlag();  //清除60ms标志

  }
}

/*********************************************************************************************************
* 函数名称：Proc60msAfter20msTask
* 函数功能：60ms后紧跟着的20ms处理任务
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
static  void  Proc60msAfter20msTask(void)    // 采集每个通道的电压数据与计算探头阻值与体温数据
{ 
  static double SENS_Val;    // S1/S2通道的电压
  double adcData;            // 经过3V3电压换算的adc数据
  if(Get60msAfter20msFlag()) // 判断60ms后紧跟着的20ms标志状态
  {
    if(keyNumber == 1)       // 通道切换为PA通道
    {      
      GetADC1Data(&adcData); // 获取adc的数据
      if(adcData >= 0)       // adc为负值说明没有获取到数据
      {
        PA_Val = adcData;    // 获取到的adc数据为PA通道的电压数据
      }
    }
    else if(keyNumber == 2)  // 通道切换为PB通道
    {
      GetADC1Data(&adcData); // 获取adc的数据
      if(adcData >= 0)       // adc为负值说明没有获取到数据
      {
        PB_Val = adcData;    // 获取到的adc数据为PB通道的电压数据
        ReckonToC1AndC2(PA_Val,PB_Val,&C1,&C2); //通过上述PA与PB各自通道获取到的电压数据从而计算出C1与C2系数
      }
    }
    else if(keyNumber == 3)  // 通道切换为S1/S2通道
    {
      if((BoolKeyModel() == 1)||(BoolKeyModel() == 2))   // 确定按钮选择的通道为S1/S2通道
      {
        ReadTOffValue = (BitAction)GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_5);  // 获取T_SENS_OFF引脚的电平变化（高与低）
        if(!ReadTOffValue)            // 当T_SENS_OFF引脚出现低电平（导联没有脱落的情况）
        {
          GetADC1Data(&adcData);      // 获取adc的数据 
          if(adcData >= 0)            // adc为负值说明没有获取到数据
          {
            SENS_Val = adcData;       // 获取到的adc数据为S1/S2通道的电压数据          
            reckonBegin = TRUE;       // 成功采集到S1/S2通道的电压数据，可以计算对应探头的阻值与温度值
          }
        }
        else                          // 当T_SENS_OFF引脚出现高电平（导联脱落的情况）
        {
          
        }
  
        // 采集完对应通道的电压数据后将通道恢复成初始按钮代表的通道，目的是要在串口波形小工具中实时显示该通道的电压数据
        if(BoolKeyModel() == 2)       // 将此刻通道恢复成S1通道  
        {
          TempWriteBit(T_SENS1);      // S1通道相关引脚赋予高电平（工作）状态
        }
        else                           // 将此刻通道恢复成S2通道  
        {
          TempWriteBit(T_SENS2);       // S2通道相关引脚赋予高电平（工作）状态
        }
      }
      else if(BoolKeyModel() == 3)     // 将此刻通道恢复成PA通道  
      {
        TempWriteBit(T_PA);            // PA通道相关引脚赋予高电平（工作）状态
        
      }
      else if(BoolKeyModel() == 0)     // 将此刻通道恢复成PB通道  
      {
        TempWriteBit(T_PB);            // PB通道相关引脚赋予高电平（工作）状态
      }
      else                             // 其他情况（严谨）
      {
        
      }
      
    }
    else                               // 其他情况（严谨）
    {
      
    }
    
    keyNumber = (keyNumber + 1) & 3;                           // 通道切换为下一个通道（当keyNumber为0时通道切换结束）
    
    if(reckonBegin)                                            // 计算探头阻值与温度值，reckonBegin为1说明已成功采集到S1/S2通道的电压数据
    {
      reckonBegin = FALSE;                                     // 为下次判断是否成功采集到S1/S2通道的电压数据做准备
      RextVariate = RextReckon(SENS_Val,C1,C2);                // 计算探头阻值
      arrTempVariate[arrNum] = RextTurnToTemp(RextVariate);    // 计算温度值并储存在体温数组中
      arrNum++;                                                // 数组元素个数加1
      keyBegin++;                                              // 进入到下一轮
    }
    
    if((keyBegin <= 4) && (keyNumber == 0) && (ReadTOffValue == 0))  
    // 都满足以下条件时体温通道继续自动切换：
    // 1、1s时间内还没有采集完5个体温值
    // 2、已采集到体温数据
    // 3、导联不脱落
    {
      keyNumber = 1;       // 体温通道自动切换为PA通道
    }
    else if(ReadTOffValue) // 导联脱落时
    {
      keyBegin = 0;        // 回到未采集体温数据的状态
      keyNumber = 0;       // 通道停止自动切换
    }
      
    Clr60msAfter20msFlag();  //清除60ms后紧跟着的20ms标志
  }
}

/*********************************************************************************************************
* 函数名称：Proc1SecTask
* 函数功能：1s处理任务 
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
static  void  Proc1SecTask(void)               
// 体温数据包的状态与数据更新并将打包好的体温数据包发送到上位机，还有其他变量状态的更新
{ 
  double  adcData;                             // 已经过3V3电压换算的adc数据
  
  if(Get1SecFlag()) //判断1s标志状态
  {
    GetADC1Data(&adcData);                     // 获取在S1/S2通道下的adc数据
    
    if(adcData >= 0)                           // 从缓存队列中取出1个数据
    {
      
      ReadTOffValue = (BitAction)GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_5);  // 获取T_SENS_OFF引脚的电平变化（高与低）
      
      if(keyChange)                            // 单片机按钮被按下选择通道
      {
        keyChange = FALSE;                     // 执行完按钮按下并在500ms时间中的任务后将值改为false
        keyBegin = 5;                          // 允许通道切换从起始值无通道开始按照keyNumber规定的通道切换顺序执行
      }
      
      if((BoolKeyModel() == 1)||(BoolKeyModel() == 2) ||(ReadTOffValue == 1))   // 处理体温值并发送体温数据到上位机
      // 以下三种情况满足if条件：
      // 1、选择S1、S2测量通道
      // 2、体温探头导联脱落
      { 
        ChangeTempDataPacket();                // 将采集到的5个体温值求平均值并把数据发送到PCT协议当中体温数据包的数组
        SendTempToHost(s_arrTempData);         // 发送数据包到上位机
      }
      
      InitValue();          // 初始化变量
    }
    
    if(keyBegin > 0)       // 重置keyBegin与keyNumber值表示从头开始按照keyNumber规定的通道自动切换采集体温值
    {
      keyBegin = 0;         // 体温数据处于未采集的状态
      keyNumber = 1;        // 通道切换设置为PA通道
    }
    
    if(ReadTOffValue == 1)  // 体温探头导联脱落的情况
    {
      RestoreJudge = TRUE;  // 为体温探头导联重新连接时从头开始采集数据做准备
      keyBegin = 0;         // 体温数据处于未采集的状态
      keyNumber = 0;        // 通道切换停止
    }
    else                    // 体温探头导联重新连接的情况
    {
      if(RestoreJudge)      // 满足上一秒导联脱落且这一秒导联连接时重置keyBegin与keyNumber值表示从头开始按照keyNumber规定的通道自动切换采集体温值
      // 作用：防止刚烧录程序还没有按下按钮时自动进行通道切换功能
      {
        keyBegin = 0;       // 体温数据处于未采集的状态
        keyNumber = 1;      // 通道切换设置为PA通道
        RestoreJudge = FALSE;  // 完成通道自动切换与体温采集轮数的初始化
      }
    }
    
    
    Clr1SecFlag();  //清除1s标志
  }    
}

/*********************************************************************************************************
* 函数名称：main
* 函数功能：主函数 
* 输入参数：void
* 输出参数：void
* 返 回 值：int
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
int main(void)
{ 
  InitHardware();   //初始化硬件相关函数
  InitSoftware();   //初始化软件相关函数
  
  printf("Init System has been finished.\r\n" );  //打印系统状态

  while(1)
  {
    // 2ms处理任务：               按键扫描与识别（每10ms进行一次按键识别）              
    // 60ms处理任务：              通道切换功能，为后续采集各个电压数据和计算体温数据做准备
    // 60ms后紧跟着的20ms处理任务： 采集每个通道的电压数据与计算探头阻值与体温数据
    // 1s处理任务：                体温数据包的状态与数据更新并将打包好的体温数据包发送到上位机（在串口波形显示小工具中不需要这部分功能），还有其他变量状态的更新
    
    Proc2msTask();             // 2ms处理任务
    Proc60msTask();            // 60ms处理任务
    Proc60msAfter20msTask();   // 60ms后紧跟着的20ms处理任务
    Proc1SecTask();            // 1s处理任务 
    
  }
}

/*********************************************************************************************************
*                                              API函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称：InitVariable
* 函数功能：初始化参数
* 输入参数：
* 输出参数：
* 返 回 值：
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
void InitVariable(void)
{  
  InitValue();           // 初始化变量
  
  keyNumber = 0;         // 体温通道停止自动切换
  keyChange = FALSE;     // 没有按动按钮选择通道
  s_i20msBegin = FALSE;  // 60ms通道切换任务没开始，20ms数据采集计时关闭
  reckonBegin = FALSE;   // 没有采集到S1/S2通道的电压数据，不计算阻值与温度值
  RestoreJudge = FALSE;  // 不进行体温探头脱落从头开始采集数据的操作
  keyBegin = 0;          // 未采集到体温数据
  ReadTOffValue = 1;     // T_off位置电压为高电平
}

/*********************************************************************************************************
* 函数名称：InitValue
* 函数功能：初始化变量
* 输入参数：
* 输出参数：
* 返 回 值：
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
void InitValue(void)
{
  u8 i;
  
  PA_Val = 0.0;            // PA通道的val电压值
  PB_Val = 0.0;            // PB通道的val电压值
  C1 = 14700.0;            // C1系数
  C2 = 6.25;               // C2系数
  RextVariate = 0.0;       // 体温探头阻值
  arrNum = 0;              // 储存温度值的数组的元素个数

  for(i = 0;i < 10;i++)    // 储存温度值的数组初始化
  {
    arrTempVariate[i] = -10.0; 
  }
}

/*********************************************************************************************************
* 函数名称：GetArrNum
* 函数功能：获取储存温度值的数组的元素个数
* 输入参数：
* 输出参数：
* 返 回 值：
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
u8 GetArrNum(void)
{
  return arrNum;
}
